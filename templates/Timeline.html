<!-- timeline.html -->
{% extends "base.html" %}

{% block title %}Timeline Fetcher{% endblock %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>
<script>
    Chart.register(window['chartjs-plugin-annotation']);
</script>


    <style>
        #timeline-form {
            margin-bottom: 20px;
        }
        
        #rt-selection {
            width: 200px;
            height: 25px;
            font-size: 16px;
            padding: 5px;
        }
        .element-block{
            width: 90%;
            height: 90%;
        }
    </style>
{% endblock %}

{% block content %}
    {{ block_header('Order Timeline') }}
        <form id="rt-form">
            <label for="rt_number">Select RT Number:</label>
            <select id="rt_number" name="rt_number">
                <option value="">Loading...</option>
            </select>
            <input type="submit" value="Submit">
        </form>
        <div style="position: relative; height: 100%; width: 100%;">
            <canvas id="timeline-chart"></canvas>
        </div>
    {{ block_footer() }}
{% endblock %}

{% block script %}
    <script>
        const form = document.getElementById('rt-form');
        const rtSelect = document.getElementById('rt_number');
        const ctx = document.getElementById('timeline-chart').getContext('2d');
        let timelineChart = null;

        // Fetch orders and populate dropdown
        async function loadOrders() {
            try {
                const response = await fetch('/get_orders');
                const orders = await response.json();
                rtSelect.innerHTML = '';  // Clear current options

                orders.forEach(order => {
                    const option = document.createElement('option');
                    option.value = order.rt_num;  // only RT number is sent on submit
                    option.textContent = `${order.rt_num} - ${order.summary}`;
                    rtSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load orders:', error);
                rtSelect.innerHTML = '<option value="">Failed to load</option>';
            }
        }

        loadOrders(); // load when page loads


        function formatTimelineForChartjs(epicData) {
            const timeline = epicData.timeline;
            
            // Sorted list of date labels
            const labels = Object.keys(timeline).sort();
        
            // Find all possible status labels from the first day (assumes all days have same keys)
            const allStatuses = Object.keys(timeline[labels[0]]);
        
            // Build datasets: one per status
            const datasets = allStatuses.map(status => {
                return {
                    "label": status,
                    "data": labels.map(day => timeline[day][status].length)
                };
            });
        
            return {
                "labels": labels,
                "datasets": datasets,
                "title": epicData.title
            };
        }

        function generateWeekendBoxes(dateLabels) {
            const annotations = [];
            let currentBox = null;
        
            dateLabels.forEach((dateStr, idx) => {
                const day = new Date(dateStr);
                const dayOfWeek = day.getUTCDay(); // Sunday=0, Saturday=6
        
                if (dayOfWeek === 6) { // Saturday
                    // Start of weekend box (shift back 12 hours)
                    const xMin = new Date(day.getTime() - (12-4) * 60 * 60 * 1000).toISOString();
                    currentBox = {
                        type: 'box',
                        xMin: xMin,
                        backgroundColor: 'rgba(200, 200, 200, 0.5)',
                        borderWidth: 0
                    };
                } else if (dayOfWeek === 0 && currentBox) { // Sunday
                    // End of weekend box (shift forward 12 hours)
                    const xMax = new Date(day.getTime() + (12+4) * 60 * 60 * 1000).toISOString();
                    currentBox.xMax = xMax;
                    annotations.push(currentBox);
                    currentBox = null;
                }
            });
        
            return annotations;
        }
        

        // Status-to-color map
        const statusColors = {
            "Backlog": "gray",
            "Passed Initial Diagnosis": "green",
            "Awaiting Advanced Repair": "lightblue",
            "Awaiting Functional Test": "blue",
            "Done": "darkgray",
            "Scrap": "red",
            "Hashboard Replacement Program": "orange",
            "Advanced Repair": "yellow",
            "Total Boards": "black"
        };

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            const rtValue = rtSelect.value;

            try {
                const response = await fetch(`/get_timeline?rt=${rtValue}`);
                const data_raw = await response.json();

                // Clear old chart if it exists
                if (timelineChart) {
                    timelineChart.destroy();
                }

                data = formatTimelineForChartjs(data_raw);

                // Extract labels and build datasets
                const labels = data.labels;
                const datasets = data.datasets.map(ds => ({
                    label: ds.label,
                    data: ds.data,
                    borderColor: statusColors[ds.label] || 'black',
                    backgroundColor: statusColors[ds.label] || 'black',
                    fill: false,
                    tension: 0.1
                }));

                // Create chart
                timelineChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: data.title || `Timeline for RT ${data.title}`
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            annotation: {
                                display: true,
                                annotations: generateWeekendBoxes(data.labels)
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const dataset = context.dataset;
                                        const index = context.dataIndex;
                                        const label = dataset.label || '';
                                        const current = context.parsed.y;
                                    
                                        // Handle previous value (plain number array!)
                                        const prev = index > 0 ? dataset.data[index - 1] : null;
                                    
                                        // Delta logic
                                        const delta = prev !== null ? current - prev : null;
                                        const sign = delta > 0 ? '+' : '';
                                        const deltaText = delta !== null ? ` (${sign}${delta})` : '';
                                    
                                        return `${label}: ${current}${deltaText}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day'
                                },
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Count'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error fetching timeline:', error);
                alert(`Failed to fetch timeline data: ${error.message}`);
            }
        });
    </script>
{% endblock %}