{% extends "base.html" %}

{% block title %}Update JIRA Issues{% endblock %}

{% block head %}
    <style>
        .element-block{
            width: 600px;
        }
        #response {
            width: 100%;
            min-height: 300px;
            flex-grow: 1;
            padding: 10px;
            font-size: 14px;
            font-family: monospace;
            resize: none;
            box-sizing: border-box;
            white-space: pre; 
            overflow-x: auto; 
            overflow-y: auto;
        }
        form {
            margin-bottom: 20px;
        }
    </style>
{% endblock %}

{% block content %}
    {{ block_header('Update JIRA Issues') }}
    <form id="rt-form">
        <label for="rt_number">Select RT Number:</label>
        <select id="rt_number" name="rt_number">
            <option value="">Loading...</option>
        </select>
        <input type="submit" value="Update">
    </form>
    <textarea id="response" readonly></textarea>
    <div style="display: flex; align-items: center; gap: 8px;">
        <progress id="progressBar" value="0" max="1" style="width: 100%; display: none;"></progress>
        <span id="progressLabel" style="font-size: 12px; display: none;"></span>
    </div>
    {{ block_footer() }}
{% endblock %}

{% block script %}
<script>
    const form = document.getElementById('rt-form');
    const rtSelect = document.getElementById('rt_number');
    const textarea = document.getElementById('response');
    
    async function loadOrders() {
        try {
            const response = await fetch('/get_orders');
            const orders = await response.json();
            rtSelect.innerHTML = '';
    
            orders.forEach(order => {
                const option = document.createElement('option');
                option.value = order.rt_num;  // only RT number is sent on submit
                option.textContent = ` (${order.created}) ${order.rt_num} - ${order.summary} [${order.issue_count}]`;
                rtSelect.appendChild(option);
            });
        } catch (error) {
            console.error('Failed to load orders:', error);
            rtSelect.innerHTML = '<option value="">Failed to load</option>';
        }
    }
    
    loadOrders(); // load when page loads

    function log(data){
        textarea.value += data + '\n';
    }
    

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const rtNumber = rtSelect.value;
        textarea.value = '';  // Clear previous results
    
        const response = await fetch('/update_issues', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ rt_number: rtNumber })
        });
    
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let maxIssues = 0;
    
        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
    
            let lines = buffer.split('\n');
            buffer = lines.pop(); // Keep the last partial line (if any)
    
            for (const line of lines) {
                if (line.trim() === '') continue;
                try {
                    const json = JSON.parse(line);
                
                    if ('progress_update' in json) {
                        const progressBar = document.getElementById('progressBar');
                        const progressLabel = document.getElementById('progressLabel');
                        progressBar.style.display = 'block'; // Show the bar
                        progressLabel.style.display = 'block'; //show the progress label
                        maxIssues = json.total;
                        progressBar.max = json.total;
                        progressBar.value = json.current;
                        progressLabel.textContent = `${json.current}/${json.total}`;
                    } else {
                        log(line);
                    }
                } catch (err) {
                    log(`Error: ${err}`);
                }
                
            }
        }
    
        // Handle final leftover
        if (buffer.trim()) {
            const json = JSON.parse(buffer);
            const stringified = createHbString(json);
            responseTextArea.value += stringified;
            responseTextArea.scrollTop = responseTextArea.scrollHeight;
        }
    
        progressBar.value = maxIssues;
        progressBar.style.display = 'none';
        progressLabel.style.display = 'none';
    
    });
</script>
{% endblock %}